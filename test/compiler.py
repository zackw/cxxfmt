#
# Compiler invocation
#

import ConfigParser
import itertools
import json
import os
import os.path
import subprocess
import sys

import util

class CompilerTraits(object):
    """Interface for traits classes that describe the peculiarities of
       a particular family of compilers."""

    def compile_cmd(self, src, obj, tag):
        """Return an argument vector which will compile source file
           'src' into object file 'obj', with COMPILER_NAME defined as
           a preprocessor macro which expands to a string constant whose
           contents are 'tag'."""
        raise NotImplemented

    def link_cmd(self, objs, libs, exe):
        """Return an argument vector which will link object files OBJS
           and libraries LIBS to produce executable EXE."""
        raise NotImplemented

    def version_cmd(self):
        """Return an argument vector which will cause the compiler to
           identify itself."""
        raise NotImplemented

    def probe_flags(self):
        """Generate a sequence of possible additional command line
           arguments to try with this compiler.  Each list entry
           should be a 2-tuple whose first entry is additional 'flags'
           and whose second entry is additional 'libs'."""
        raise NotImplemented

class CT_Unix(CompilerTraits):
    """A compiler whose command line conforms to Unixy conventions."""

    def compile_cmd(self, src, obj, tag):
        DCOMPILER_NAME = "-DCOMPILER_NAME=" + json.dumps(tag)
        return [ DCOMPILER_NAME, "-I.", "-O2", "-o", obj, "-c", src ]

    def link_cmd(self, objs, libs, exe):
        return [ "-o", exe ] + objs + libs

    def version_cmd(self):
        return [ "--version" ]

class CT_Gcc(CT_Unix):
    """GNU Compiler Collection."""
    def probe_flags(self):
        return [ ( [], [] ),
                 ( ["-std=c++11"], [] ) ]

class CT_Clang(CT_Unix):
    """LLVM compilers."""
    def probe_flags(self):
        return [ ( [], [] ),
                 ( ["-std=c++11"], [] ),
                 ( ["-stdlib=libc++"], [] ),
                 ( ["-std=c++11", "-stdlib=libc++"], [] ) ]

class Compiler(object):
    """A particular compiler installed on this computer, which can be
       invoked to compile and link programs"""

    def __init__(self, prog, flags, libs, props, traits):
        """Constructor for Compiler instances.  'prog' is the compiler
           executable.  'flags' are extra command line arguments to
           pass to all invocations, and 'libs' are extra command line
           arguments to pass to linking invocations (after all the
           object files).  'props' is a dictionary of properties
           describing this compiler (see the 'identify' static method),
           and 'traits' is the traits class to use to construct
           command lines.

           Normally you should not use this directly; use
           'probe_compilers' or 'load_compilers' instead."""
        self.prog = prog
        self.flags = flags
        self.libs = libs
        self.traits = traits
        for k, v in props.iteritems(): setattr(self, k, v)

    def __cmp__(self, other):
        return (cmp(self.tag, other.tag) or
                cmp(self.prog, other.prog) or
                cmp(id(self), id(other)))

    def objname(self, src):
        """Return an appropriately labeled name for an object file
           compiled from source file 'src' with this compiler."""
        return os.path.splitext(src)[0] + self.otag

    def exename(self, base):
        """Return an appropriate name for an executable generated by this
           compiler, beginning with 'base'."""
        return os.path.splitext(base)[0] + self.etag

    def compile(self, src, verbose=1):
        """Compile source file 'src'.  The object file will be named
           self.objname(src).  Returns True on success, False on failure.
           'verbose' is passed through to invoke()."""
        obj = self.objname(src)
        return self.invoke(self.traits.compile_cmd(src, obj, self.tag),
                           obj, verbose)

    def link(self, objs, exe, verbose=1):
        """Link 'objs' (a list of object file names) together.  The
           resulting executable will be named self.exename(exe).
           Returns True on success, False on failure.
           'verbose' is passed through to invoke()."""
        exe = self.exename(exe)
        return self.invoke(self.traits.link_cmd(objs, self.libs, exe),
                           exe, verbose)

    @util.lazy_property
    def DEVNULL(_):
        """Read-write file handle on /dev/null.  If possible,
           delegates to subprocess; otherwise opens a global handle on
           os.devnull itself.  If possible, that handle is marked
           close-on-exec.

           N.B. this is not in 'util' because descriptors do not apply
           to lookups in module objects, and thus @lazy_property does
           not work in that context."""
        try:
            return subprocess.DEVNULL
        except AttributeError:
            try:
                return os.open(os.devnull, os.O_RDWR | os.O_CLOEXEC)
            except AttributeError:
                return os.open(os.devnull, os.O_RDWR)

    def invoke(self, args, label, verbose):
        """Invoke this compiler, passing 'args' on the command line.
           'verbose' says how much to report about this invocation.
           It takes one of the following numeric values:
              0: total silence.
              1: report success or failure.
              2: print full command line and error messages.
           'label' is used when verbose=1 to describe this invocation.
           Returns True for a successful compilation, False otherwise.
        """
        if verbose is None:
            verbose = verbosity
        if verbose < 0 or verbose > 2:
            raise ValueError("bad verbosity {}".format(verbose))

        argv = [self.prog] + self.flags + args
        if verbose == 2:
            sys.stderr.write(" ".join(argv) + "\n")
            rv = subprocess.call(argv, stdin=self.DEVNULL)
        else:
            if verbose == 1:
                sys.stderr.write("{} {}...".format(argv[0], label))
            rv = subprocess.call(argv,
                                 stdin=self.DEVNULL,
                                 stdout=self.DEVNULL,
                                 stderr=self.DEVNULL)
        if rv == 0:
            if verbose == 1:
                sys.stderr.write("ok\n")
            return True
        if verbose > 0:
            if rv < 0:
                sys.stderr.write("signal {}\n".format(-rv))
            else:
                sys.stderr.write("exit {}\n".format(rv))
        return False

    def save(self, cfg):
        """Stash everything we know about this compiler in a config file."""
        sect = self.tag
        cfg.add_section(sect)
        for v in vars(self):
            if v == 'tag': pass
            elif v == 'traits':
                cfg.set(sect, v, getattr(self, v).__class__.__name__)
            elif v == 'flags' or v == 'libs':
                cfg.set(sect, v, json.dumps(getattr(self, v)))
            else:
                cfg.set(sect, v, getattr(self, v))

    @classmethod
    def load(cls, cfg, sect):
        """Load one Compiler object from section SECT of config file CFG."""
        prog = cfg.get(sect, 'prog')
        flags = json.loads(cfg.get(sect, 'flags'))
        libs = json.loads(cfg.get(sect, 'libs'))
        traits = globals()[cfg.get(sect, 'traits')]()
        props = { 'tag': sect }
        for k, v in cfg.items(sect):
            if k != 'prog' and k != 'flags' and k != 'libs' and k != 'traits':
                props[k] = v
        return cls(prog, flags, libs, props, traits)

    @classmethod
    def load_compilers(cls, cfgfile):
        """Load all Compiler objects defined in config file CFGFILE."""
        cfg = ConfigParser.RawConfigParser()
        cfg.read(cfgfile)
        return [ cls.load(cfg, sect) for sect in cfg.sections() ]

    @staticmethod
    def save_compilers(compilers, cfgfile):
        """Write all Compiler objects to config file CFGFILE."""
        cfg = ConfigParser.RawConfigParser()
        for cc in compilers: cc.save(cfg)
        cfg.write(open(cfgfile, "w"))

    _identify_source = None
    _identify_source_gen = None
    @classmethod
    def identify_source(cls):
        if cls._identify_source is None:
            cls._identify_source_gen = util.mkstemp_autodel(suffix=".cc",
                                                            prefix="id-",
                                                            text=True,
                                                            contents=r"""
// Thanks largely to the clown show that is MacPorts, we have to
// compile and run a test program to make absolutely sure that the
// particular combination of compiler and library we're trying
// actually works.  If the compiler is already in C++11 mode, we
// include <type_traits> even though it's not actually used, to detect
// more possible incompatibilities between the compiler and the library.

#include <iostream>
#if __cplusplus >= 201103L
#include <type_traits>
#endif

using std::cout;
int main()
{
  cout << "{\n"
#if __cplusplus >= 201103L
       << "  \"cxx11\" : 1,\n"
#else
       << "  \"cxx11\" : 0,\n"
#endif
// clang defines __GNUC__ and might plausibly decide to define
// _MSC_VER on Windows, so check for it first.
#if defined __clang__
       << "  \"cc\"    : \"clang\",\n"
       << "  \"ccmaj\" : " << __clang_major__ << ",\n"
       << "  \"ccmin\" : " << __clang_minor__ << ",\n"
#elif defined __GNUC__
       << "  \"cc\"    : \"gcc\",\n"
       << "  \"ccmaj\" : " << __GNUC__ << ",\n"
       << "  \"ccmin\" : " << __GNUC_MINOR__ << ",\n"
#elif defined _MSC_VER
       << "  \"cc\"    : \"msvc\",\n"
       << "  \"ccmaj\" : " << _MSC_VER << ",\n"
       << "  \"ccmin\" : 0,\n"
#else
       << "  \"cc\"    : \"unknown\",\n"
       << "  \"ccmaj\" : 0,\n"
       << "  \"ccmin\" : 0,\n"
#endif
#if defined _LIBCPP_VERSION
       << "  \"lib\"   : \"llvm\"\n" // "libc++" is too generic
#elif defined __GLIBCXX__
       << "  \"lib\"   : \"gnu\"\n"
#elif defined _MSC_VER
       << "  \"lib\"   : \"ms\"\n"
#else
       << "  \"lib\"   : \"unknown\"\n"
#endif
       << "}\n";
  return 0;
}
""")
            cls._identify_source = cls._identify_source_gen.__enter__()
        return cls._identify_source

    @classmethod
    def identify(cls, prog, extra_args, verbose):
        """Subroutine of 'probe_compilers' (below).  Find out which version of
           which compiler 'prog' is, and which C++ runtime library it
           offers, when invoked with 'extra_args'.  'prog' should be
           an absolute pathname to an executable."""

        source = cls.identify_source()
        with util.mkstemp_autodel(suffix=".exe", prefix="id-") as exe:
            try:
                # This is how g++ and clang++ want to be invoked.
                argv = [prog] + extra_args + ["-o", exe, source]
                if verbose >= 2:
                    sys.stderr.write(" ".join(argv) + "\n")
                    cc_stderr = None
                else:
                    cc_stderr = cls.DEVNULL
                    if verbose == 1:
                        sys.stderr.write("probe " + " ".join(argv[:-3]) + "...")
                subprocess.check_call(argv,
                                      stdin=cls.DEVNULL,
                                      stdout=cls.DEVNULL,
                                      stderr=cc_stderr)
                output = subprocess.check_output(exe)
                fail = False

            except subprocess.CalledProcessError, e:
                # Retry with appropriate switches for MSVC should go here.
                # I am getting a headache just looking at its documentation,
                # so it can wait.
                if verbose >= 1:
                    if e.returncode < 0:
                        sys.stderr.write("{} signal {}\n".format(e.cmd[0],
                                                                 -e.returncode))
                    else:
                        sys.stderr.write("{} exit {}\n".format(e.cmd[0],
                                                               e.returncode))

                output = """{ "cxx11" : 0,
                              "cc"    : "unknown",
                              "ccmaj" : 0,
                              "ccmin" : 0,
                              "lib"   : "unknown" }"""
                fail = True

        props = json.loads(output)
        props["ccver"] = str(props["ccmaj"]) + "." + str(props["ccmin"])
        tag = props["cc"] + "-" + props["ccver"] + "-lib" + props["lib"]
        otag = "-" + tag
        etag = otag
        if os.name == "nt" or os.name == "ce":
            otag += ".obj"
            etag += ".exe"
        else:
            otag += ".o"
            etag += ".x"

        props["tag"] = tag
        props["otag"] = otag
        props["etag"] = etag

        if verbose >= 1 and not fail:
            sys.stderr.write(tag)
            if props["cxx11"] == 1:
                sys.stderr.write(" (ok)\n")
            else:
                sys.stderr.write(" (not C++11)\n")
        return props

    @classmethod
    def pick_traits(cls, prog):
        """Subroutine of probe_compilers().  Pick the appropriate
        traits class for the compiler named 'prog'."""
        try:
            output = subprocess.check_output([prog] + CT_Unix().version_cmd(),
                                             stderr=cls.DEVNULL)
        except CalledProcessError:
            return None

        output = output.lower()
        if "gcc" in output: return CT_Gcc()
        elif "clang" in output: return CT_Clang()
        else: return None

    @classmethod
    def probe_compilers(cls, progs, verbose=0):
        compilers = []
        for prog in progs:
            traits = cls.pick_traits(prog)
            if traits is None:
                if verbose >= 1:
                    sys.stderr.write("no known traits for " + prog + "\n")
                continue

            for flags, libs in traits.probe_flags():
                props = cls.identify(prog, flags + libs, verbose)
                if props["cxx11"] == 1:
                    compilers.append(cls(prog, flags, libs, props, traits))

        return compilers

def find_compilers(candidates, verbose):
    if len(candidates) == 0:
        candidates = ["g++", "clang++"]
    candidates = set(candidates)

    compilers = []

    if os.path.exists("compilers.ini"):
        compilers = Compiler.load_compilers("compilers.ini")
        for cc in compilers:
            candidates.discard(cc.prog)

    compilers.extend(Compiler.probe_compilers(candidates, verbose))

    if len(compilers) == 0:
        raise RuntimeError("no usable compilers identified")
    Compiler.save_compilers(compilers, "compilers.ini")
    return compilers

if __name__ == '__main__':
    def main():
        verbose = 0
        args = sys.argv[1:]
        while len(args) > 0 and args[0] == '-v':
            verbose += 1
            args.pop(0)
        if len(args) == 0:
            args = ["g++", "clang++"]

        compilers = Compiler.probe_compilers(args, verbose)
        Compiler.save_compilers(compilers, "compilers.ini")
    main()
