# Test generator for cxxfmt.

# Copyright 2012 Zachary Weinberg <zackw@panix.com>.
# Use, modification, and distribution are subject to the
# Boost Software License, Version 1.0.  See the file LICENSE
# or http://www.boost.org/LICENSE_1_0.txt for detailed terms.

# This Python program generates a C++ program which will test cxxfmt.
# You need to compile its output, compile fmt.cc, link them together,
# and run the result.  The output of that program should be
# self-explanatory.

class TestBlock(object):
    def __init__(self, mod, name, casetype, generator):
        self.mod = mod
        self.name = name
        self.casetype = casetype
        self.generator = generator

    def __cmp__(self, other):
        # primary sort alpha by module
        if self.mod < other.mod: return -1
        if self.mod > other.mod: return 1

        # sort any block named 'simple' to the top within its module
        if self.name == "simple" and other.name != "simple": return -1
        if self.name != "simple" and other.name == "simple": return 1

        # otherwise, alphabetical
        if self.name < other.name: return -1
        if self.name > other.name: return 1
        return 0

    def emit(self, pattern, outf=None):
        txt = pattern.format(**vars(self))
        if outf is not None:
            outf.write(txt)
        return txt

    def fullname(self):
        return self.emit("{mod}.{name}")

    def write_cases(self, outf):
        self.emit("const {casetype} {mod}_{name}[] = {{\n", outf)
        for case in self.generator():
            outf.write("  { " + case + " },\n")
        outf.write("};\n\n")

    def write_tblock_obj(self, outf):
        self.emit("const tblock<{casetype}> "
                  "{mod}_{name}_b(\"{mod}.{name}\", {mod}_{name});\n", outf)

    def write_tblocks_entry(self, outf):
        self.emit("  &{mod}_{name}_b,\n", outf)

class TestGenerator(object):
    def __init__(self):
        self.blocks = []
        self.duplicate_preventer = set()

    def add_block(self, block):
        f = block.fullname()
        if f in self.duplicate_preventer:
            raise KeyError(f + " already registered")
        self.blocks.append(block)
        self.duplicate_preventer.add(f)

    def add_module(self, name, casetype, contents):
        for k, v in contents.iteritems():
            if k.startswith('g_'):
                self.add_block(TestBlock(name, k[2:], casetype, v))

    def generate(self, outf):
        self.blocks.sort()

        for b in self.blocks: b.write_cases(outf)
        for b in self.blocks: b.write_tblock_obj(outf)

        outf.write("\nconst i_tblock *const tblocks[] = {\n")
        for b in self.blocks: b.write_tblocks_entry(outf)
        outf.write("};\nconst size_t n_tblocks = "
                   "sizeof(tblocks) / sizeof(tblocks[0]);")

words = [ '', 'i', 'of', 'sis', 'fice', 'drisk', 'elanet', 'hippian',
          'botanist', 'synaptene', 'cipherhood', 'schizognath' ]

aligns = [ '', '<', '>', '^', 'L<', 'R>', 'C^' ]

maxw = len(words) + 3

def output(spec, val):
    spec = '{:' + spec + '}'
    return '"{}", "{}", "{}"'.format(spec, spec.format(val), val)

def g_simple():
    for r in words:
        for a in aligns:
            yield output(a, r)

def g_width():
    for r in words:
        for w in xrange(1, maxw):
            for a in aligns:
                yield output('{}{}'.format(a, w), r)

def g_prec():
    for r in words:
        for p in xrange(maxw):
            for a in aligns:
                yield output('{}.{}'.format(a, p), r)

def g_wnp():
    for r in words:
        for w in xrange(1, maxw):
            for p in xrange(maxw):
                for a in aligns:
                    yield output('{}{}.{}'.format(a, w, p), r)

skeleton_top = r"""// Tester for cxxfmt.

// Copyright 2012 Zachary Weinberg <zackw@panix.com>.
// Use, modification, and distribution are subject to the
// Boost Software License, Version 1.0.  See the file LICENSE
// or http://www.boost.org/LICENSE_1_0.txt for detailed terms.

// This program was generated by test_fmt.py.  DO NOT EDIT.
// Edit test_fmt.py instead.

#ifndef COMPILER_NAME
#define COMPILER_NAME "unknown"
#endif

#include <cstring>
#include <string>
#include <iostream>
#include <fmt.h>

using std::strcmp;
using std::string;
using std::cout;
using std::flush;
using fmt::format;

namespace {

bool quiet = false;

// Note: Plain arrays of POD structures are used because some
// compilers are not yet very good at optimizing std::initializer_list,
// leading to gargantuan assembly output and very slow object file
// generation.

struct case_1arg_s
{
  const char *spec;
  const char *expected;
  const char *val;
};

// more case_ structures here

static bool
report(const char *spec, string const& got, const char *expected)
{
  if (got == expected)
    return true;
  else {
    if (!quiet)
      cout << "\nFAIL: " << spec
           << ": want '" << expected
           << "', got '" << got
           << '\'';
    return false;
  }
}

template <typename case_1arg>
static bool
process(const case_1arg *cases, size_t n)
{
  bool success = true;
  for (const case_1arg *c = cases; c < cases+n; c++) {
    string got(format(c->spec, c->val));
    success &= report(c->spec, got, c->expected);
  }
  return success;
}

// more process_ overloads here

struct i_tblock { virtual bool operator()(const char *) const = 0; };

template <typename case_1arg>
struct tblock : i_tblock
{
  template <size_t N>
  tblock(const char *tag_, const case_1arg (&cases_)[N])
    : tag(tag_), cases(cases_), n(N)
  {}

  virtual bool operator()(const char *label_) const
  {
    string label(label_);
    label += '\t';
    label += tag;
    if (!quiet)
      cout << label << "..." << flush;
    bool success = process(cases, n);
    if (!quiet) {
      if (success)
        cout << " ok\n";
      else
        cout << '\n'; // failures printed already
    }
    return success;
  }

private:
  const char *tag;
  const case_1arg *cases;
  size_t n;
};

"""

skeleton_bot = r"""

} // anonymous namespace

int
main(int argc, char **argv)
{
  if (argc > 1 && !strcmp(argv[1], "-q"))
    quiet = true;
  bool success = true;
  for (size_t i = 0; i < n_tblocks; i++)
    success &= (*tblocks[i])(COMPILER_NAME);
  return success ? 0 : 1;
}
"""

def main(argv, outf):
    if len(argv) > 1:
        outf = open(argv[1], "w")
    with outf:
        gen = TestGenerator()
        gen.add_module('strings', 'case_1arg_s', globals())

        outf.write(skeleton_top)
        gen.generate(outf)
        outf.write(skeleton_bot)

if __name__ == '__main__':
    import sys
    main(sys.argv, sys.stdout)
